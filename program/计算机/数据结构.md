### 树

#### 二叉树

##### 数组存储

二叉树比较常见的是用链式指向进行存储，同样亦可用数组进行存储，为了遵循可以通过公式计算即可找出节点位置，存储时会将树补完成完全二叉树再存储，因此：
- 完全二叉树会浪费下标为 0 的存储位置
- 非完全二叉树的话，其实会浪费更多的数组存储空间



**公式**

左节点: 2 * i
右节点: 2 * i + 1



**复杂度**

删除：logn，只会将位置数据置0，避免了数组的n



### 图

#### 概念

有向边
无向边
混合图
度数 关联边数
出度  出去边数
入度  进入边数
自环
通路  一条路线  包含n个点 n-1条边
（通路边互异，顶点可能相同）
简单通路  路线上顶点互异

起点=终点  环路  （边互异）
环路上边互异，但顶点可能重复
如果所有的点均互异则为简单环路

欧拉环路
经过全部边一次，的环路  长度等于边总数

经过全部顶点且一次  哈密尔顿环路



### 堆栈

栈存储基本变量类型

堆存储引用类型，栈中变量通过地址指向堆变量



#### 堆

堆是一颗完全二叉树，这样实现的堆也被称为二叉堆



堆中节点的值都大于等于（或小于等于）其子节点的值，堆中如果节点的值都大于等于其子节点的值，我们把它称为大顶堆，如果都小于等于其子节点的值，我们将其称为小顶堆。



存储：

由于完全二叉树的特性，可以直接用数组存储，可以通过公式算出节点位置



### Hash

Hash根据数据计算出一个固定长度的引用，通常是利用数论的单向函数来计算，是不可逆的



最常用的两种加密散列函数：MD5、SHA



##### MD5



漏洞较多，不安全

工作原理:是获取可变长度的数据并将其转换为128位的固定长度哈希字符串



##### SHA

SHA-1:

SHA-2:SHA-224、 SHA-384、 SHA-256、 SHA-512

SHA-3:

### **HashTree**

hash理论上可以O(1)，但是映射依赖于映射函数，当数据量大时容易出现冲突从而降低效率

质数树：第一层为两个节点，第二层为6个节点（各3个）....，只要10层就可以存储2 * 3 * 5 .... 很大的数据

HashTree则是将数据存储到质数树中，数据对每层的质数取余，根据取余结果查看位置是否被占用，被占用则以此余数为路径，往下一层进行取余

```
root -> 2
     -> 1 

# 存储3时，3 % 2 = 1，第一层取余为1的位置已经被1占据，顺着取余为1的路径进行3 % 3 = 0

root -> 2
     -> 1 -> 3 (取余为0的位置))
```



#### **特点**

- 单向增加、结构不变：为了避免结构变化产生的损耗，树的大小只增不减，空间换时间
- 节点动态增加：每层节点的子节点个数为连续的质数。子节点可以随时创建。因此哈希树的结构是动态的，不需要为不存在的关键字提前分配空间
- 查找迅速：对于整数，哈希树层级最多能增加到10。因此最多只需要十次取余和比较操作，就可以知道这个对象是否存在，一般的树状结构，往往随着层次和层次中节点数的增加而导致更多的比较操作。操作次数可以说无法准确确定上限。而哈希树的查找次数和元素个数没有关系

#### **缺点**

不支持排序



#### 实现

**查找**

根据树的层数进行取余查找，能快速的查找是否存在



**删除**

哈希树的节点删除过程也很简单，哈希树在删除的时候，并不做任何结构调整。
只是先查到到要删除的节点，然后把此节点的“占位标记”置为false即可（即表示此节点为空节点，但 并不进行物理删除）。



#### **应用**

哈希树可以广泛应用于那些需要对大容量数据进行快速匹配操作的地方。
- 数据库索引系统
- 短信息中的收条匹配
- 大量号码路由匹配
- 信息过滤匹配
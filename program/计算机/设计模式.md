### 原则

#### 开闭原则

对拓展开发，对修改闭合，在加新功能时尽量不对原有代码进行修改，而是在基础上进行扩展，所以代码要写成便于扩展



接口对于开闭原则的意义

> 抽象好稳定的接口，通过接口限制来保证架构稳定



应用：通过面向接口编程实现，只包含抽离后的通用逻辑，核心逻辑则依赖于接口的实现（依赖倒置）



#### **里氏替换原则**

场景：子类替代父类时？

子类可以扩展父类的功能，但不能改变父类原有的功能

- 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
- 子类中可以增加自己特有的方法。
- 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。（由于方法重载，当传入参数更宽泛时，始终是调用子类的方法，不会对父类产生影响）
- 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。



#### 依赖倒置

高层模块不直接依赖低层的实现，而是依赖于低层模块的抽象



面向接口编程，代码逻辑依赖于抽象，不依赖于具体实现，抽象的实例从外部输入



#### **接口隔离原则**

接口隔离原则偏向于根据业务进行划分，单个接口会包含多个功能职责，但均指向于所对应业务所必须的接口



单一职责会被接口隔离包含，单一职责更关注松耦合，接口隔离更关注高内聚





### 工厂模式

作用：创建对象



#### 简单工厂

例：接口定义产品，有n个产品，但只有一个工厂



使用：工厂内实现根据传入的类型返回对应的产品,少量产品时使用

缺点：新增时，需要定义新产品，然后修改工厂，工厂容易臃肿

改善：可以通过反射来改善简单工厂

通过反射 + 配置文件，即可替代工厂模式



##### 工厂模式

例：接口定义产品和工厂，有n个产品和n个工厂，各自实现自己的产品和工厂

使用：传入类型Class?根据反射可以创建对应的工厂，然后产出对应的产品，大量产品扩展时使用

优点：新增时，只需实现自己的产品和工厂，不需要反复修改旧有的工厂

工厂模式和抽象工厂模式区别，对工厂进行了抽象



##### 抽象工厂

一个工厂对应n个的产品，每个产品有n种系列，然后有多少系列就有多少个工厂

> 一个工厂需要定义n个产品，新增产品时需要修改所有工厂？





### 策略模式

依赖倒置



工厂和策略可以组合使用进行解耦



### 责任链

每个 else if 分支都包含了复杂的条件判断，且其对执行的先后顺序有所要求

```js
const rules = [
  {
    match: function (a, b, c) { /* ... */ },
    action: function (a, b, c) { /* ... */ }
  },
  {
    match: function (a, b, c) { /* ... */ },
    action: function (a, b, c) { /* ... */ }
  },
  {
    match: function (a, b, c) { /* ... */ },
    action: function (a, b, c) { /* ... */ }
  }
  // ...
]

// 按顺序进行匹配并且执行
function demo (a, b, c) {
  for (let i = 0; i < rules.length; i++) {
    if (rules[i].match(a, b, c)) {
      return rules[i].action(a, b, c)
    }
  }
}

```






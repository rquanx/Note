#### 常见包管理

##### nuget

**分类**

- 普通包

- 元包（不包含DLL和依赖）

- 描述了一组放在一起有意义的包



##### maven



##### npm

V5后Lock文件为固定版本

只需要 package.lock 文件就可以确定 node_modules 目录结构



##### yarn

生成的node_module目类结构与npm V5一样，lock文件不同，会出现语义化版本范围符号，需要同时依赖 package.json 和 yarn.lock 两个文件才能确定 node_modules 目录结构

- 快速：全局缓存、并行下载、离线模式
- 安全：安装包被执行前校验其完整性
- 可靠：lockfile文件、确定性算法



##### cnpm

- 生成的 node_modules 目录采用的是和 npm 不一样的布局，在 node_modules 文件夹下以 版本号 @包名 命名，然后再做软链接到只以包名命名的文件夹上

> 软链：减少磁盘占用，保持了 node_modules 的目录结构清晰

- 不生成lock文件



#### 语义化版本

- 主版本号：当你做了不兼容的 API 修改
- 次版本号：当你做了向下兼容的功能性新增
- 修订号：当你做了向下兼容的问题修正



- ~：只升级修订号
- ^：升级次版本号和修订号
- *：升级到最新版本

> xxx@~16.x.y

#### 循环依赖

##### CommonJS

运行时加载，并且加载后会被缓存，不会产生循环依赖导致的无限循环，但会存在初始化的问题

##### ES6

import优先，即使import写在最低，也会优先执行



 import 是在编译阶段执行的，程序在编译时就能确定模块的依赖关系，一旦发现循环依赖，ES6 本身就不会再去执行依赖的那个模块

> a --> b  ; b --> a;  执行a -> 加载b -> 忽略a -->...



#### 依赖地狱

常见包管理测试，当依赖同一个库不同版本时，会根据路径最短...多种方式选定依赖于什么版本的包

> 子库依赖自己的包，不需要管？



##### nuget

包存储在全局上，并且拍平

> 存放规则：包/版本/内容
>
> 对于包的依赖，通过描述文件定义，同样拍平到全局存储上



##### npm

V1：嵌套存储，容易造成浪费空间、并且嵌套过深

V3：优先拍平，出现冲突时退化回嵌套

> 为了避免浪费存储，对库进行提升或下降，从而实现包共用和依赖地狱问题，但会产生由于包依赖版本与需要使用的版本不一致导致问题

V5: ~



##### pnpm

另外一种思路仍然保持依赖地狱，但通过软链的方式来公用库，进一步减少存储消耗的情况下也解决了版本冲突问题，由于软链，存在一些问题




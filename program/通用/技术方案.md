#### 延迟队列

- Redis ZSet:每个元素有score（延迟时间）,并且排序，定时取分数最小的调用（小于或等于当前时间）
- RabbitMQ : 死信队列 + TTL
- TimeWheel（时间轮）

#### 插件机制

1、对象存储插件，通过插件名来作为key

2、指定插件的执行函数

3、执行时，对特定插件或全部插件执行插件的执行函数，并且把设计的值传入

> 声明周期、loader?



#### Map缓存

以Map作为缓存存放在内存中时产生的并发问题



作为临界资源时，需要加读写锁，实施互斥，读写前后进行锁和解锁（将Map当作数据库，相当于数据库 库级别锁）



并发访问时锁导致延迟

- 进行水平拆分，将1个Map拆分成n个Map

- 将Map优化成array??

- 无锁缓存(有可能出现不一致的脏数据)



##### 无锁缓存

作为缓存，允许cache miss（读取直接返回空），却不允许读脏数据



**不做优化**

（1）线程1对缓存进行操作，对key想要写入value1；

（2）线程2对缓存进行操作，对key想要写入value2；

（3）不加锁，线程1和线程2对同一个定长区域进行一个并发的写操作，可能每个线程写成功一半，导致出现脏数据产生，最终的结果即不是value1也不是value2，而是一个乱七八糟的不符合预期的值value-unexpected；



**签名优化**

（1）线程1对缓存进行操作，对key想要写入value1，写入签名v1-sign；

（2）线程2对缓存进行操作，对key想要写入value2，写入签名v2-sign；

（3）如果不加锁，线程1和线程2对同一个定长区域进行一个并发的写操作，可能每个线程写成功一半，导致出现脏数据产生，最终的结果即不是value1也不是value2，而是一个乱七八糟的不符合预期的值value-unexpected，但签名，一定是v1-sign或者v2-sign中的任意一个；

（4）数据读取的时候，不但要取出value，还要像消息接收方收到消息一样，校验一下签名，如果发现签名不一致，缓存则返回NULL，即cache miss；





#### 延时消息实现

##### 需求

在发起/完成任务后，n小时/n天后执行xxx

 

###### 方案

###### 轮询

隔一小时轮询执行任务

缺点：重复查询、浪费性能、可能存在时效问题

优点：相对稳定



###### loop

前置：

1、环形队列，3600格

2、task list，每一格都是一个task的list,里面存储执行的任务和Cycle-Num

3、current-index

 

运行：

每秒执行一次，每次current-index + 1,每次遍历taskList，Cycle-num为0的执行，否则减1

产生task的时候，根据延迟的时间计算出cycle-nul和cycle格子

 

优点：相对高效、通用、时效性好

缺点：主要task不能是耗时任务，需保持可用性，崩溃恢复



#### 数据变化监控

1、全量取数据到内存中

2、定时检查对比，找出差异项

3、推送通知

每天定时全量修正数据



#### 读写分离

一主多从，读写分离，主动同步



- 主库，提供数据库写服务

- 从库，提供数据库读服务

- 主从之间，通过某种机制同步数据，例如mysql的binlog

一个组从同步集群通常称为一个“分组”。



**场景**

一般场景都是读多写少，特别是互联网行业，读数据的量比写数据的量高

**使用**

成本较高，一般优先通过增加缓存的方式来提高缓存的内容



#### 数据库扩展

**业务场景**：单库结构太旧，且容易受影响




数据库层面的负载均衡，既要考虑数据量的均衡，又要考虑负载的均衡



##### 水平切分架构

**范围法**

按用户主键，以区间的方式进行范围内的切人，0 ~ 1000W，1000W ~ 2000W

**优点**

- 切分策略简单

- 扩容简单

**缺点**

- uid必须要满足递增的特性
- 数据量分布不均，新库在前期数量会很少
- 请求量不均，新用户会相对活跃，导致新库会收到更多请求




**哈希法**

根据hash平分，由于hash是相对随机的，所以基本可以均分

**优点**

- 请求量均衡
- 数据量均衡
- 切分策略简单，计算简单，快速定位

**缺点**

- 扩容麻烦，扩容后由于算法原因，需要进行数据迁移



**方案问题**

当不通过id进行查找时，难以通过切分算法来定位库

**场景**
用户侧，前台访问，最典型的有两类需求：
（1）用户登录：通过登录名login_name查询用户的实体，1%请求属于这种类型；
（2）用户信息查询：登录之后，通过uid来查询用户的实例，99%请求属这种类型；

运营侧，后台访问，根据产品、运营需求，访问模式各异，按照年龄、性别、头像、登陆时间、注册时间来进行查询

**解决方法**

用户侧，特点基本都是单行记录的访问，采用“建立非uid属性到uid的映射关系”的架构方案；如login_name

- 索引表法：对login_name建立与ID的索引表，先索引出ID再进行查询，数据量大时再用此属性进行分库，额外多进行一次数据库查询
- 缓存映射法：用内存存储login_name->ID映射，cache不命中时扫描数据库，快，需要进行一次cache查询
- 生成uid法：建立函数可从login_name生成ID，注册时直接生成ID，login_name值不可变，有碰撞风险，一般不使用
- 基因法：根据算法，判断影响库命中的是哪些值，例如最后3bit，从login_name中提前基因作为3bit，然后与uid拼接成为唯一ID,常用方案，可能不平均？？

运营侧，特点基本是批量分页的访问，计算量较大，比较消耗数据库性能，采用“前台与后台分离”的架构方案；
对于“业务复杂”“并发量低”“无需高可用”“能接受一定延时”的后台业务,与用户侧进行解耦，单独独立服务，避免影响用户侧使用

- 可以去掉service层，在运营后台web层通过dao直接访问db；
- 不需要反向代理，不需要集群冗余；采用数据冗余的设计方式
- 不需要访问实时库，可以通过MQ或者线下异步同步数据；
- 在数据库非常大的情况下，可以使用更契合大量数据允许接受更高延时的“索引外置”（例如ES搜索系统）或者“HIVE”（大数据处理）的设计方案；



##### 水平拆分 VS 垂直拆分

**水平拆分**

一个表的数据均匀分配到多个表中

- 结构一样

- 数据不一样

- 所有表并集才是全量数据



**垂直拆分**

将一个表字段拆分成多个表

- 表结构不一样
- 数据一样，但至少会有一列会产生交集
- 所有表并集才是全量数据




**拆分准则**

- 长度短，访问频率较高放在一个表里，这个表暂且称为主表；
- 字段长，访问频率较低放在一个表里，这个表暂且称为扩展表；
- 经常一起访问的属性，也可以放在一个表里



**原因**

- 数据库有自己的内存缓冲池，会将磁盘上的数据load到缓冲池里；
- 数据库缓冲池，以row为单位缓存数据；
- 在内存有限的情况下，在数据库缓冲池里缓存短row，就能缓存更多的数据；
- 在数据库缓冲池里缓存高频访问row，就能提升缓存命中率，减少磁盘的访问；

总结：假定内存缓冲池最大缓存大小为xG,属性、数据越少主表就能缓存更多的数据，提高缓存命中率，提高性能



#### 单点登录

1、同父域名，子域名可获取父级域名的cookies

2、跨域
跨域携带 Cookie

```js
xhrFields: {
  withCredentials: true
}
```

但是这种方式CORS 需要指定可访问的域名，不能设置为*，可通过其他方式实现类似*的效果

3、CAS
CAS（Central Authentication Service），即中央认证服务
通过中间认证来实现





#### 方案技巧

##### 撤销、重做功能实现：

1、undostack、redostack,每次修改将对象信息序列化存储，通过栈操作实现

简单，但是容易占用内存

2、创建操作对象，每次入栈都建立操作对象，通过操作对象来控制

复杂，需要推导正向和逆向操作，编辑器实现方式



##### 取余

> 如果用户访问，当数据量足够大的时候，可以通过取余进行均分
>
> % 2 平分
>
> % 3 、%4 ...  可以实现数据不同概率的分布
>
> 视频缓存?
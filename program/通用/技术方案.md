#### 延时消息实现

##### 需求

在发起/完成任务后，n小时/n天后执行xxx

 

###### 方案

###### 轮询

隔一小时轮询执行任务

缺点：重复查询、浪费性能、可能存在时效问题

优点：相对稳定



###### loop

前置：

1、环形队列，3600格

2、task list，每一格都是一个task的list,里面存储执行的任务和Cycle-Num

3、current-index

 

运行：

每秒执行一次，每次current-index + 1,每次遍历taskList，Cycle-num为0的执行，否则减1

产生task的时候，根据延迟的时间计算出cycle-nul和cycle格子

 

优点：相对高效、通用、时效性好

缺点：主要task不能是耗时任务，需保持可用性，崩溃恢复



#### 数据变化监控

1、全量取数据到内存中

2、定时检查对比，找出差异项

3、推送通知

每天定时全量修正数据



#### 读写分离

一主多从，读写分离，主动同步



- 主库，提供数据库写服务

- 从库，提供数据库读服务

- 主从之间，通过某种机制同步数据，例如mysql的binlog

一个组从同步集群通常称为一个“分组”。



**场景**

一般场景都是读多写少，特别是互联网行业，读数据的量比写数据的量高

**使用**

成本较高，一般优先通过增加缓存的方式来提高缓存的内容



#### 数据库扩展

**业务场景**：单库结构太旧，且容易受影响




数据库层面的负载均衡，既要考虑数据量的均衡，又要考虑负载的均衡



##### 水平切分架构

**范围法**

按用户主键，以区间的方式进行范围内的切人，0 ~ 1000W，1000W ~ 2000W

**优点**

- 切分策略简单

- 扩容简单

**缺点**

- uid必须要满足递增的特性
- 数据量分布不均，新库在前期数量会很少
- 请求量不均，新用户会相对活跃，导致新库会收到更多请求




**哈希法**

根据hash平分，由于hash是相对随机的，所以基本可以均分

**优点**

- 请求量均衡
- 数据量均衡
- 切分策略简单，计算简单，快速定位

**缺点**

- 扩容麻烦，扩容后由于算法原因，需要进行数据迁移



**方案问题**

当不通过id进行查找时，难以通过切分算法来定位库

**场景**
用户侧，前台访问，最典型的有两类需求：
（1）用户登录：通过登录名login_name查询用户的实体，1%请求属于这种类型；
（2）用户信息查询：登录之后，通过uid来查询用户的实例，99%请求属这种类型；

运营侧，后台访问，根据产品、运营需求，访问模式各异，按照年龄、性别、头像、登陆时间、注册时间来进行查询

**解决方法**

用户侧，特点基本都是单行记录的访问，采用“建立非uid属性到uid的映射关系”的架构方案；如login_name

- 索引表法：对login_name建立与ID的索引表，先索引出ID再进行查询，数据量大时再用此属性进行分库，额外多进行一次数据库查询
- 缓存映射法：用内存存储login_name->ID映射，cache不命中时扫描数据库，快，需要进行一次cache查询
- 生成uid法：建立函数可从login_name生成ID，注册时直接生成ID，login_name值不可变，有碰撞风险，一般不使用
- 基因法：根据算法，判断影响库命中的是哪些值，例如最后3bit，从login_name中提前基因作为3bit，然后与uid拼接成为唯一ID,常用方案，可能不平均？？

运营侧，特点基本是批量分页的访问，计算量较大，比较消耗数据库性能，采用“前台与后台分离”的架构方案；
对于“业务复杂”“并发量低”“无需高可用”“能接受一定延时”的后台业务,与用户侧进行解耦，单独独立服务，避免影响用户侧使用

- 可以去掉service层，在运营后台web层通过dao直接访问db；
- 不需要反向代理，不需要集群冗余；采用数据冗余的设计方式
- 不需要访问实时库，可以通过MQ或者线下异步同步数据；
- 在数据库非常大的情况下，可以使用更契合大量数据允许接受更高延时的“索引外置”（例如ES搜索系统）或者“HIVE”（大数据处理）的设计方案；



##### 水平拆分 VS 垂直拆分

**水平拆分**

一个表的数据均匀分配到多个表中

- 结构一样

- 数据不一样

- 所有表并集才是全量数据



**垂直拆分**

将一个表字段拆分成多个表

- 表结构不一样
- 数据一样，但至少会有一列会产生交集
- 所有表并集才是全量数据




**拆分准则**

- 长度短，访问频率较高放在一个表里，这个表暂且称为主表；
- 字段长，访问频率较低放在一个表里，这个表暂且称为扩展表；
- 经常一起访问的属性，也可以放在一个表里



**原因**

- 数据库有自己的内存缓冲池，会将磁盘上的数据load到缓冲池里；
- 数据库缓冲池，以row为单位缓存数据；
- 在内存有限的情况下，在数据库缓冲池里缓存短row，就能缓存更多的数据；
- 在数据库缓冲池里缓存高频访问row，就能提升缓存命中率，减少磁盘的访问；

总结：假定内存缓冲池最大缓存大小为xG,属性、数据越少主表就能缓存更多的数据，提高缓存命中率，提高性能
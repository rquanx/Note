### 工厂模式

#### 简单工厂

例：接口定义产品，有n个产品，但只有一个工厂



使用：工厂内实现根据传入的类型返回对应的产品,少量产品时使用

缺点：新增时，需要定义新产品，然后修改工厂，工厂容易臃肿

改善：可以通过反射来改善简单工厂

通过反射 + 配置文件，即可替代工厂模式



##### 工厂模式

例：接口定义产品和工厂，有n个产品和n个工厂，各自实现自己的产品和工厂

使用：传入类型Class?根据反射可以创建对应的工厂，然后产出对应的产品，大量产品扩展时使用

优点：新增时，只需实现自己的产品和工厂，不需要反复修改旧有的工厂

工厂模式和抽象工厂模式区别，对工厂进行了抽象



##### 抽象工厂

一个工厂对应n个的产品，每个产品有n种系列，然后有多少系列就有多少个工厂

> 一个工厂需要定义n个产品，新增产品时需要修改所有工厂？





### 责任链

每个 else if 分支都包含了复杂的条件判断，且其对执行的先后顺序有所要求

```js
const rules = [
  {
    match: function (a, b, c) { /* ... */ },
    action: function (a, b, c) { /* ... */ }
  },
  {
    match: function (a, b, c) { /* ... */ },
    action: function (a, b, c) { /* ... */ }
  },
  {
    match: function (a, b, c) { /* ... */ },
    action: function (a, b, c) { /* ... */ }
  }
  // ...
]

// 按顺序进行匹配并且执行
function demo (a, b, c) {
  for (let i = 0; i < rules.length; i++) {
    if (rules[i].match(a, b, c)) {
      return rules[i].action(a, b, c)
    }
  }
}

```






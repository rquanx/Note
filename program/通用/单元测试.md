#### why

85%的缺陷都在码设计阶段产生，而发现bug的阶段越靠后，耗费成本就越高，指数级别的增高



保持unit test代码的稳定，主要靠好的API设计。

> API切实正确切割了需求，那么在重构的时候API就基本不用变化，unit test也不用重写。



重构的时候，只要unit test覆盖的够好，可以节省大量的时间。

#### effect

- bug类指标（间接指标）：连续迭代的bug总数趋势、迭代内新建bug的趋势、千行bug率

- 单测的需求覆盖度（50%以上），参与人员覆盖度（80%以上）单测case总数趋势，代码行增量趋势

- 增量代码的行覆盖率（接入层80%，客户端30%）

- 单函数圈复杂度（低于40），单函数代码行数（低于80），扫描告警数



#### how

参考pnpjs



#### 关键点

- 测试越简明越好，每个测试只关注一个点。
- 如果测试运行失败，则其应发出有帮助性的错误消息或提示,Assert时加上异常说明？
- 使用简单明确的测试输入条件。
- 给测试用例取一个可描述的名字。

##### 命名

- `Test_<ClassName>_<FunctionName>_<Situation>` 风格
- `Given_<State>_When_<Behavior>_Then_<SomethingHappen>`风格

#### 原则

需包含Arrange, Act, Assert

- Arrange：定义变量、入参
- Act：调用要测试的函数、代码
- Assert：验证输出是否是预期的结果

#### 分类

- 小型测试：针对单个函数的测试，关注其内部逻辑，mock所有需要的服务。

> 小型测试带来优秀的代码质量、良好的异常处理、

优雅的错误报告

- 中型测试：验证两个或多个制定的模块应用之间的交互

- 大型测试：也被称为“系统测试”或“端到端测试”。大型测试在一个较高层次上运行，验证系统作为一个整体是如何工作的。



#### 作用

提高代码正确性：快速执行代码验证代码是否和预期一致，并保留多套测试参数
- 验证运行步骤
- 验证执行结果
- 验证异常、边界情况
- 验证代码效率、资源损耗
- 验证不同参数下不同场景

发现设计问题：强制性思考代码封装性，从如何写单元测试 --> 促进代码的分离和测试性
- 方法封装合理性
- 代码可测试性

代码可读性：通过单元测试可推断代码的功能
- 易写单测的方法一定是简单好理解的，可读性是高的，反之难写的单测代码是复杂的，可读性差的

代码优化：从单元测试的调用方式、入参来对api进行优化重构，优化不必要的操作

#### 工具

- 测试框架
- Mock工具

[headless-recorder](https://github.com/checkly/headless-recorder)


### 技术

学习:技术是什么，为什么，解决了什么问题

> 技术主要作用：降低门槛



#### 主流技术

主流技术的形成需要满足：

- 大公司背书

- 杀手级应用

- 强大的社区



#### 进阶方向

语言层面：编程范式、设计模式、代码设计

原理层面：操作系统、网络、数据库、计算机

理论：算法、架构、分布式



#### 体系

​					  编程能力

架构能力 --> 前端知识 --> 领域知识

​					  工程能力

##### 提升

编程能力：刻意练习

架构能力：读源码，参与来源项目，看issue带着问题看源码，解决问题

工程能力：？？？

前端知识：CSS、DOM等特有知识

领域知识：特定业务，埋点等



##### 知识体系划分

看规范标准，参考规范的分类，划分来进行自身知识体系的划分



**学习方法**

追踪溯源

1、找最早的源头：例如查闭包，谷歌->维基百科->history->找到源头(看到作者，作者的文章)

2、权威文档（mdn w3c等）

3、大师观点：高级大佬的相关文章





### 规范

#### 提交



##### 范围

每次提交尽量单元少



##### 日志



**记录修改什么、谁修改**

1、知道谁修改，代码出现bug找谁

> 远程期间，出问题，定位是林金

> 后续拉代码后无法编译，定位王康

> sql疯狂查询，定位陈超

> 代码漏上传，快速定位孟松



2、写上修改人、时间

> 更快速查找
>
> 丢失日志也能知道



### 编程模式

#### 依赖注入

对象生命周期控制

- 自动控制单例模式

- 自动控制sql连接



#### AOP



### 计算机底层

#### 虚函数

在内存中为了函数复用和多个类公用函数



在类到实际函数间增加虚函数表，类只记录虚函数表中的地址，虚函数表中再指向实际函数

> 解耦，实现多态
>
> 多态：每个类都有一个虚函数表，当方法被重写时，对应虚函数中指向的方法发生变化



### 原则

#### 优化

性能优化只应该在瓶颈上做，因为做在非瓶颈上就是浪费资源

不必太担心性能——必要时再来优化



#### 命名设计

标记名应说明它「允许什么」而非「拒绝什么」。建议遵循「默认拒绝」的最佳实践来保证安全性



### 知识点

#### 编码（写代码）

例如：使用中文属性，会有编码问题，由于编码乱掉

代码抉择：是性能优先还是逻辑优先，有时候部分操作算法可以考虑牺牲计算机一些性能来让算法逻辑更加清晰、易懂



### 重构

- 命名调整
- 一个函数只做一件事（分离逻辑）
- 消耗不大的循环可以拆分
- 通过类聚合处理方法和数据，工厂类抽离，多态实现面对不同类型的需求



### 协程

协程是一种比线程更加轻量级的存在，协程处在线程的环境中，一个线程可以存在多个协程，可以将协程理解为线程中的一个个任务。不像进程和线程，协程并不受操作系统的管理，而是被具体的应用程序代码所控制，因此并没有进程/线程上下文切换的开销



### 代码规则

#### 好的代码

- 构造函数参数数量、顺序
- Field 与 Property的区别
  - Field：类内部的数据，应该是私有成员变量
  - Property：对象内部可以被用户设置或者读取的属性
- Property是否开放
- 利用继承划分类的功能
- 函数返回值
  - 如果你总是期待函数返回一个值，而值不存在时则应该抛出异常；
  - 如果你期待函数可以返回一个不存在的值，则可以返回 null
  - 利用命名区分
- 异常
  - 开发时：正常的代码是不需要 try..catch.. 的，异常就应该一抛到底直至应用程序崩溃
  - 

#### 设计原则

##### SRP 单一职责原则

代码封装，类、方法只干一件事

##### OCP 开闭原则

对扩展开放，对修改关闭

- 通过继承和多态扩展来添加新功能
- 对于已完成且正常运行的部分，通常情况下不应该去修改它

##### LSP 里式替换原则

使用父类的地方都可以用子类替代

- 父类最好为抽象类
- 子类可实现父类的非抽象方法，尽量不要覆盖重写已实现的方法
- 子类可写自身的方法，有自身的特性，在父类的基础上扩建
- 子类覆盖重写父类方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松，后置条件（返回值）要更严格

##### ISP 接口隔离原则

- 减少代码耦合
- 客户端不应该依赖它所不需要的接口

##### DIP 依赖倒置原则

- 高级模块不应该依赖低级模块，两者都应该依赖抽象（接口？）
- 抽象不应该依赖于细节，细节应该依赖于抽象（接口？）

##### DRY 原则、KISS 原则、YAGNI 原则、LOD 法则

- DRY：不要干重复的事儿。
- KISS：不要干复杂的事儿，思从深而行从简。
- YAGNI：不要干不需要的事儿，尺度把握尤为重要，超越尺度则会有过度设计之嫌。
- LOD：最小依赖

##### 高内聚 松耦合

高内聚：相近功能放在同一类中，相近功能往往会被同时修改，放到同一个类中在修改时，代码更易维护
松耦合：类与类之间的依赖关系简单清晰，一个类的代码改动不会或者很少导致依赖类的代码修改





### Hard Code

对于数据即使是常量也要用变量存储
当被复用时，如果有参数变化，不要随意修改元素的名字，直接赋值

> 内部逻辑依赖于变量,且较为通用,即使外部传入变化,内部可不变



### CR

[Review机制搭建](https://segmentfault.com/a/1190000025141916)



#### 技术委员会

**痛点**

人员分布在各个项目：

- 重复踩坑

- 代码质量难以把控

- 代码设计质量难以把控

- 重复造轮子，难以沉淀



**作用**

技术委员会：

- 把控代码质量

- 交流设计思路和编码实践

- 统一规范

- 沉淀



#### 方式

规范化、平台化、自动化

- 宣讲：宣讲代码规范、同步认知
- Review小组：初期由经验丰富的人员参与，迭代同步标准后可逐步吸纳人员，并对规范进行讨论完善
- 设定Review评价维度和标准
  - 基本：代码量、是否符合规范
  - 架构设计：设计是否合理、设计文档、设计方案
  - 代码：简单、易读、便于维护、代码划分、代码抽离、合理使用已有库
  - 健壮性：异常处理、边界处理、明显Bug、安全性
  - 沉淀：提取、沉淀
- 申请表：提供所需的基本信息
- Review要求
  - 提出时机
  - Review结果处理
  - Review反馈
  - Review记录
- Review重点
- 整体流程


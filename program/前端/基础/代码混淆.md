[前端代码混淆](<https://segmentfault.com/a/1190000019423501>)



#### AST混淆
##### 变量名混淆

- 变量重名为短名称
- 混入16进制，增加混淆程度

> eval混淆（非静态代码分析）会有一定难度
> 作为输出的全局变量，为确保可用，需进行保护防止被混淆



##### 常量提取

- 将常量混入到数组、二维数组、三维数组中，只要确保使用的地方能正确获取即可达到混淆的目的

> 从普通字面类型的变量获取 --> 通过函数从对象中获取



##### 常量混淆

- 文字变Unicode编码，js自动支持转换
- 算法加密，读取时通过解密函数还原



##### 运算混淆

- 普通运算表达式变成函数（函数调用，常量均可使用类似的方式处理）



##### 语法丑化

- 在不变化代码功能的情况下，怎么难读怎么处理，例：for ==> do while，do while使用较少，也可增加难度



##### 动态执行

- 普通表达式 ==> 1真1假的两个函数，通过在某个地方设置，让代码始终执行真的函数，if(true) ? （废逻辑插入）



##### 流程混淆


- 顺序扁平化

> 顺序代码 ==> switch case,执行流程不再从上到下

- 条件扁平化

> if else ==> switch case



##### 不透明谓词

- switch case一般时常量，可变成表达式，并且使用变量计算的表达式，将变量（常量）存储在某个地方即可



##### 脚本加壳

- 代码加密 + 参数传递

> aaencode ，是用一些看似表情的符号，声明了一个16位的数组（用来表示16进制位置），然后将code当做字符串遍历，把每个代码符号通过取这个16位的数组下标，拼接成代码。大概的意思就是把代码当做字符串，然后使用这些符号的拼接代替这一段代码



#### 反调试

死循环 + debugger来增加控制台调试难度

- setTimeout定时执行反调试函数
- 代码编译阶段，随机插入反调试函数调用



#### 内容检测

防止通过override的方式将代码保存，修改后执行

- 代码自检：为代码生成hash，然后发现hash不正确则进行处理
- 环境自检：检测URL是否允许使用、当前执行环境，进行数据监控上报/启用木马（node.js环境）等



#### 废代码注入

插入永不执行的代码来混淆



##### 废逻辑插入

增加假代码，并且增加一些逻辑判断，但必定会执行真代码



##### 求值陷阱

类似内容检测，插入正常情况不会执行的代码，特定情况执行时，可

- 数据上报
- 木马/本地记录，长期跟踪
- 释放CSRF漏洞，反追踪
- 开启自杀，（页面崩溃、死循环、大量占用内存）



##### 加壳干扰

在代码用eval包裹，然后对eval参数进行加密，并埋下陷阱，在解码时插入无用代码，干扰显示，大量换行、注释、字符串等大量特殊字符，导致显示卡顿。
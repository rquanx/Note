#### 简述

JS中使用IEEE754 标准(IEEE 二进制浮点数算术标准)表示整数和浮点数



#### 存储方式

浮点数存储（科学计数法）：Value = sign * exponent * fraction

> 例：0.1 的二进制 0.00011001100110011…… 
>
> 表示为：1 * 2^-4 * 1.1001100110011……
>
> sign = 1   exponent = 2^-4   fraction = 1.1001100110011……



**二进制科学计数**

当只进行二进制数存储时可简化表达式为：V = (-1)^S * (1 + Fraction) * 2^E

> S 用来标记正负
>
> 1 + Fraction 按科学计数法和二进制，必为1.xxxx，所以fraction可以留出1，然后只存储后面的数据，减少占用
>
> E 幂次,E可以为负



**移码**

由于E可以是负数，为了解决存储问题，对E进行位移（加一定的值）从而只存储正数，在计算时再减回去

> 例:使用8bit存储时，大小为-127~127，所以存储E + bias，
>
> 在8bit时，bias = 127 = 2^7 - 1 == 2^(bit - 1) - 1



#### 标准

在IEEE754 标准中

- 正负:1bit

- 幂次:11bit

- Fraction:52bit



> 根据规范，0.1完整表示则是
>
> 0 01111111011
>
> 1001100110011001100110011001100110011001100110011010

> S = 0, E = 2^(bit - 1) - 1 = -4 + 2^(11 - 1) - 1 = 1019

> 由于0.1是无限循环，所以在存储0.1的时候已存在精度丢失



#### 计算

二进制运算

1、对阶：两个数变成幂次相等的形式

2、尾数运算：普通加减

3、规格化：转化为科学计数形式

舍入处理：规格化后，结果位数超过精度，则最后一位会被舍去，且根据四舍五入，0舍1入

溢出判断：...



以0.1 + 0.2为例，存储时精度丢失 + 运算时舍入精度丢失导致 0.1 + 0.2 != 0.3
#### 设计

##### 内存模式

文档-->段落-->文字（文字分割 + 行内样式） + 行样式



#### 演进

分别为针对以下几点的改进作为演进路线

- 模型：自定义的 JSON 数据格式作为内存模型，它的压缩版本作为存储模型；
- 渲染：借助浏览器排版，用 React 框架渲染视图；
- 编辑：不依赖 contenteditable，拦截浏览器事件判断用户交互，自己实现了光标和选区；
- 指令：实现了丰富的自定义的富文本编辑指令，重新实现了 execCommand 执行指令。



##### **第一代**

完全基于浏览器 API 设计，数据模型直接采用 HTML 数据，渲染用原生 HTML，编辑区域用 contentEditable 生成，通过 execCommand 执行浏览器自带的修改 HTML 数据的指令

应用：常见于Demo中，基本没有成熟的开源编辑器或者商用编辑器采用这一种设计方式
缺点：

- execCommand 只提供了有限的几个命令，例如 execCommand 就没有办法支持插入待办列表。
- 提供的命令有些有功能受限，例如 'fontSize' 命令只能支持 1-7，导致不能自定义字体的大小。
- 修改的结果与浏览器有关，例如 'bold' 命令在一些浏览器上会给选区中的文字添加<b>标签，而在另一些浏览器上则会添加<strong>标签。



##### **第二代**

由于 execCommand 功能上的限制，第二代的编辑器普遍抛弃了用浏览器的 execCommand 接口直接修改 HTML 文档的办法，而是用自己实现的 execCommand 和指令修改 HTML 文档

目的：解决execCommand 功能上的限制，自定义指令控制
缺点：不同的 HTML 结构可能表示的含义一样，利用html标签，嵌套的先后顺序不一样但是效果一样，对比较数据是否一样就变得非常困难



##### **第三代**

针对 HTML 含义不一致的问题，第三代编辑器则抛弃了既用 HTML 做文档模型，又用 HTML 做渲染的策略，而是采用自定义的数据模型，例如 XML 数据模型或者 JSON 数据模型。同样的数据模型渲染生成的 HTML 一样，自定义的操作则可以保证同样的操作修改之后的文档模型也是一样的

目的：解决直接使用Html导致的不一致性，自定义渲染模型
产品：有道云笔记、石墨文档等，以及开源的编辑器库例如 Slate、Draft、Quill 等
缺点：能够满足大多数应用场景，但由于渲染出的页面中，可编辑区域还是基于 contentEditable，需要根据拦截的事件判断用户行为，生成对应的指令修改数据模型。一旦有用户数据没有拦截，或者处理的行为不对，用户的行为就可能直接修改了 contentEditable 的元素，导致数据和视图的不一致。因此产生的 bug 定位和修复都比较难，在编辑器的移动端适配中经常出现



##### **第四代**

彻底抛弃的 contentEditable，自己实现排版引擎。排版引擎控制了文档的页面和布局，将数据渲染成为页面上的HTML。同时由于抛弃了contentEditable，还需要解决实现光标和选区的绘制、监听文字输入事件等技术问题，才可以做到和浏览器类似的编辑体验

产品：Google Docs
目的：解决contentEditable 引起的不可控事件，自定义编辑、排版引擎
缺点：开发难度更高、体验不如原生、可能会遇到性能问题



- 没有可编辑的元素，不会触发输入事件
  
  > 利用隐藏的 input，捕获输入事件
- 没有可编辑的元素，无法使用浏览器自带的光标
  
  > 自绘光标
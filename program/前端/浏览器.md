### 浏览器知识

#### Cookies

##### 第三方Cookies

网站可以注入一些非当前域名的Cookies(第三方)，当你访问这个第三方网站(例：facebook)，或当前站点向第三方网站发生请求，这样第三方应用就能将你的信息联系起来



##### 应用

单点登录

大数据收集

异常、数据监控



#### SameSite Cookie

为了应对浏览器禁用第三方Cookies的特性，禁止将Cookies跨域名发送



##### 解决

浏览器隐式设置关闭 block第三方cookies









#### 跨域

##### URI

```
[协议名]://[用户名]:[密码]@[主机名]:[端口]/[路径]?[查询参数]#[片段ID]
```

##### 同源

协议、主机名(host)以及端口三者均相同

> 主域和子域视为不同、域名与其对应的IP也视为不同
>
> 看着必须一样



##### 限制

Cookie、LocalStorage 和 IndexDB 无法读取。

DOM 无法获得。

AJAX 请求被拦截



##### CORS 跨域资源共享

Cross-origin resource sharing

###### 简单请求

**什么是简单请求**

普通 HTML Form 在不依赖脚本的情况下可以发出的请求



**特征**

三种请求方式之一：HEAD、GET、POST

 Header信息不超出以下几种字段

- Accept
- Accept-Language
- Content-Language
- Last-Event-ID
- Content-Type
  - application/x-www-form-urlencoded
  - multipart/form-data
  - text/plain
- DPR
- Downlink
- Save-Data
- Viewport-Width
- Width



**过程**

1、浏览器发送

浏览器会在Request Header中添加 Origin （协议 + 域名 + 端口）字段 ， 它表示我们的请求源，CORS服务端会将该字段作为跨源标志



2、服务器处理

接收到此次请求后 ， 首先会判断Origin是否在允许源（由服务端决定,Access-Control-Allow-Origin）范围之内，然后在Response Header 添加 Access-Control-Allow-Origin、Access-Control-Allow-Credentials等字段

必须字段

Access-Control-Allow-Origin

> 表示服务端允许的请求源，*标识任何外域，多个源 , 分隔,浏览器接收响应后会用来校验



可选字段

Access-Control-Allow-Credentials：false

> 表示是否允许发送Cookie，设置为true,同时，ajax请求设置withCredentials = true,浏览器的cookie就能发送到服务端



Access-Control-Expose-Headers

> 调用getResponseHeader（）方法时候，能从header中获取的参数



3、浏览器接收

浏览器收到Respnose后会判断自己的源是否存在 Access-Control-Allow-Origin允许源中，如果不存在，会抛出“同源检测异常”



###### 预检请求

OPTIONS方法发起一个预检请求(preflight request)



**什么是预检请求**

**为什么有预检请求**

**预检请求作用**

询问服务器某个资源是否可以跨源，如果不允许的话就不发实际的请求,如果允许的话，浏览器会记住，然后发实际请求，且之后每次就都直接请求而不用再询问服务器否可以跨源了。



###### 复杂请求

普通 HTML Form 无法实现的请求

发起前会先发生预检请求，供服务器校验



###### 为什么要有简单请求、复杂请求

1、默认禁止跨源请求

许多服务器压根没打算给跨源用。当然你不给 CORS 响应头，浏览器也不会使用响应结果，但是请求本身可能已经造成了后果。所以最好是默认禁止跨源请求。

2、回答请求是否接受跨域总是要计算的，所以希望最好不用每次请求都让服务器劳神计算，从而有预检机制,节省服务器计算

3、简单请求是为了兼容普通表单发送请求而加入CORS机制？普通表单请求不经过CROS?

兼容的前提下发 preflight 对绝大多数服务器应用来说没有意义

没必要加，加了反而系统复杂化

4、为了安全考虑，由于服务器api并不会对调用拦截，只要api开放了，就可以被随意调用，所以浏览器通过CORS来block掉请求

如果浏览器没有CORS，则请求会直接发出去

是浏览器自身为了安全考虑增加的



#### API

`getEventListeners($(‘selector’))` 

返回一个对象数组，其中包含绑定到该元素的所有事件



`monitorEvents($(‘selector’))` 

将监视与选择器的元素关联的所有事件，然后在它们被触发时将它们打印到控制台



`queryObjects()`

可以遍历出 V8 堆上以某对象为原型的对象们，而且执行前会先做一次垃圾回收



`queryHolders(target)`

它可以找到某个对象被哪些对象所引用了，仅Safari ?




#### 并发数量

Http1.1下 根据域名划分
> 并非数量最大6个？
> 优化：将资源分布到多个域名下



浏览器只能同时向一个域下载8个文件？？
老的只能2个



#### 存储

Cookie、LocalStorage、sessionStorage与IndexedDB

![img](..\..\Note.assets\169fb22fcd34051a)



### 性能

#### 重排和重绘

##### 定义

- 重排：**重新生成布局**。当DOM 的变化影响了元素的几何属性（宽和高）
  - 改变边框宽度或给段落增加文字导致行数增加
  - 浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程称为重排。
- 重绘：**重新绘制**。完成重排后，浏览器会重新绘制受影响的部分到屏幕中。这个过程称为重绘。



##### 重排与重绘的关系

**重排一定会导致重绘**，重绘不一定导致重排。如果DOM变化不影响几何属性，元素的布局没有改变，则只发生一次重绘（不需要重排）。



##### 发生重排的情况

当页面布局和几何属性改变时发生“重排”。如下：

- 添加或删除可见的DOM 元素
- 元素位置改变
- 元素尺寸改变（包括外边距、内边距、边框厚度、宽度、高度等属性改变）
- 内容改变，例如：文本改变后图片被另一个不同尺寸的图片替代
- **页面渲染器初始化**
- **浏览器窗口尺寸改变**



##### 发生重排的范围

整个页面或局部。例如：当滚动条出现时触发整个页面的重排。



##### 触发

```js
// 浏览器优化一次重排和重绘,会批量进行操作
div.style.color = 'blue';
div.style.marginTop = '30px';


// 由于中间会获取几何位置，会马上触发=>触发两次
div.style.color = 'blue';
var margin = parseInt(div.style.marginTop);
div.style.marginTop = (margin + 10) + 'px';
```

`offsetTop`, `offsetLeft`, `offsetWidth`, `offsetHeight`
`scrollTop`, `scrollLeft`, `scrollWidth`, `scrollHeight`
`clientTop`, `clientLeft`, `clientWidth`, `clientHeight`

获取以上属性时都会触发强制刷新



##### 优化

```js
// bad
div.style.left = div.offsetLeft + 10 + "px";
div.style.top = div.offsetTop + 10 + "px";

// good
var left = div.offsetLeft;
var top  = div.offsetTop;
div.style.left = left + 10 + "px";
div.style.top = top + 10 + "px";
/*
一般的规则是：
样式表越简单，重排和重绘就越快。
重排和重绘的DOM元素层级越高，成本就越高。
table元素的重排和重绘成本，要高于div元素。
*/
```





#### 并发限制

没有做并发限制，较大文件导致并发过多，tcp
链接被占光 ，需要做下并发控制，比如只有4个在请求在发送



#### 垃圾回收

回收原则：不可达的被回收

回收算法：标记清除算法

一般来说没有被引用的对象就是垃圾，就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除

### DevTool

#### 命令

Ctrl + P 

> 快速查找代码



#### Console

##### 复制

copy(location) 可复制对象内容到剪切板



##### keys/values

获取对象的key和value



##### monitor(function)/unmonitor(function)

监听函数的调用

> 只对functoin声明有效？



##### monitorEvents(object[, events])/unmonitorEvents(object[, events])

监听事件



##### 清空控制台

clear()

console.clear()



#### Element

##### 调色器
调色器可以进行rgba、16进制…..等颜色转换

##### 对元素右键
  break on:可以在元素被删除或其他操作时自动断点



##### Eventlistener 

右键 show defined可以找到函数定义处



#### Source
  ##### xhr/fetch breakpoints
    添加，可以捕获所有的url地址，也可以指定关键字捕获

  ##### 异常时自动暂停
    单步调试最右在异常时自动暂停，try catch中也能自动暂停

  ##### overrides
    在线调试：选择文件夹后，直接编辑网站的代码，刷新即可生效

##### Scope

利用好scope栏查看变量





#### Network

Network下右键copy as fetch

```js
// 可以复制整个请求并且手动发送 
var r = await fetch();console.log(await r.json())
```

### 知识点

#### target="_blank"

当对a标签设置了target="_blank"时会产生的问题

```html
<a href="http://kaysonli.com/" target="_blank">1024译站</a>
```

**安全**

打开的新窗口可以通过window.opener读取并修改原窗口的信息，即使跨域被限制访问部分属性，仍会有一定的隐患



**性能**

通过target="_blank"打开的新窗口，会跟原来的页面窗口共用一个进程（看实际浏览器实现），阻塞会影响原页面

### 问题

请求完成，但返回的缺少内容

> js缺少内容
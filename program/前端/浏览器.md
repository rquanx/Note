## safari

### 兼容性

#### 日期对象

```js
new Date("2018/11/11 00:00:00")    

new Date("2018-11-11 00:00:00")  // error
	
// 有时间时,不支持-	
// 无时间时支持 -
```







## IE

### 样式

#### 基础

**对于输入框，会自带有叉和查看密码**

```css
::-ms-clear,
::-ms-reveal
{
	display:none;
}
/* 通过css清除 */
```



### 兼容性

#### 日期对象

```js
new Date("2018/09/09 00:00:00")    

new Date("2018-9-9 00:00:00")  // error

// 不支持缺少0 	
// 有时间时,不支持-	
// 无时间时支持 -
```

#### 兼容ES6

[让ie  兼容es6](http://www.hangge.com/blog/cache/detail_1691.html)

- 使用polyfill
  1、页面全局引用
  2、react内引入，在最顶部引入，或在webpack中设置打包



## Chrome

### 事件监控

#### 获取绑定的事件

Chrome	window.getEventListeners(e).keyup

#### 触发事件

代码主动触发事件dispatchEvent

例：input.dispatchEvent(new KeyboardEvent('keyup', {'key':'y'}));





### 内存管理

#### 分类

- 新生代：通常只支持 1～8M，为了效率，所以空间设置小一点，但是为了避免容易被塞满，有晋升机制

- 老生代





#### 垃圾回收

- 副垃圾回收器，主要负责新生代的垃圾回收。

- 主垃圾回收器，主要负责老生代的垃圾回收



#### 关联概念

**内存碎片**：

概念：内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片

作用：当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况



**全停顿**

由于JS单线程问题，老生代的清理会占用大量时间导致页面卡顿，所以利用增量标记（Incremental Marking）算法，将清理任务拆分为子任务进行执行



#### 新生代

**算法**：Scavenge

**空间使用**：空间对半划分为两个区域，一半是对象区域，一半是空闲区域。新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。



**清理步骤**

- 先对对象区域中的垃圾做标记；

- 进入垃圾清理阶段，副垃圾回收器会存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，清楚内存碎片

- 完成复制后，对象区域与空闲区域进行角色翻转



**对象晋升策略**：经过两次垃圾回收依然还存活的对象，会被移动到老生区中



##### 老生代

- 标记 - 清除（Mark-Sweep）算法

- 标记 - 整理（Mark-Compact）算法



### Cookies

#### 第三方Cookies

网站可以注入一些非当前域名的Cookies(第三方)，当你访问这个第三方网站(例：facebook)，或当前站点向第三方网站发生请求，这样第三方应用就能将你的信息联系起来



#### 应用

单点登录

大数据收集

异常、数据监控



### SameSite Cookie

为了应对浏览器禁用第三方Cookies的特性，禁止将Cookies跨域名发送

**解决**：浏览器隐式设置关闭 block第三方cookies





### API

`document.activeElement`

当前获得焦点的元素

$0：高亮当前所选中的node



`getEventListeners($(‘selector’))` 

返回一个对象数组，其中包含绑定到该元素的所有事件



`monitorEvents($(‘selector’))` 

将监视与选择器的元素关联的所有事件，然后在它们被触发时将它们打印到控制台



`queryObjects()`

可以遍历出 V8 堆上以某对象为原型的对象们，而且执行前会先做一次垃圾回收



`queryHolders(target)`

它可以找到某个对象被哪些对象所引用了，仅Safari ?



`copy`

复制对象内容到剪切板



`keys()/values()`

获取对象的key和value



`monitor(function)/unmonitor(function)`

监听函数的调用

> 只对functoin声明有效？



`monitorEvents(object[, events])/unmonitorEvents(object[, events])`

监听事件



`clear`

清空控制台



### 其他


#### 并发数量

Http1.1下 根据域名划分
> 并非数量最大6个？
> 优化：将资源分布到多个域名下



浏览器只能同时向一个域下载8个文件？？
老的只能2个



### 存储

Cookie、LocalStorage、sessionStorage与IndexedDB

![img](..\..\Note.assets\169fb22fcd34051a)



### 性能

#### 术语

TTFB

> Time to   first byte 
>
> 浏览器开始收到服务器响应数据的时间



#### 重排（回流）和重绘

##### 定义

- 重排（回流）：**重新生成布局**。当DOM 的变化影响了元素的几何属性（宽和高）
  - 改变边框宽度或给段落增加文字导致行数增加
  - 浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程称为重排。
- 重绘：**重新绘制**。完成重排后，浏览器会重新绘制受影响的部分到屏幕中。这个过程称为重绘。



##### 重排与重绘的关系

**重排一定会导致重绘**，重绘不一定导致重排。如果DOM变化不影响几何属性，元素的布局没有改变，则只发生一次重绘（不需要重排）。



##### 发生重排的情况

当页面布局和几何属性改变时发生“重排”。如下：

- 添加或删除可见的DOM 元素
- 元素位置改变
- 元素尺寸改变（包括外边距、内边距、边框厚度、宽度、高度等属性改变）
- 内容改变，例如：文本改变后图片被另一个不同尺寸的图片替代
- **页面渲染器初始化**
- **浏览器窗口尺寸改变**



##### 发生重排的范围

整个页面或局部。例如：当滚动条出现时触发整个页面的重排。



##### 触发

```js
// 浏览器优化一次重排和重绘,会批量进行操作
div.style.color = 'blue';
div.style.marginTop = '30px';


// 由于中间会获取几何位置，会马上触发=>触发两次
div.style.color = 'blue';
var margin = parseInt(div.style.marginTop);
div.style.marginTop = (margin + 10) + 'px';
```

`offsetTop`, `offsetLeft`, `offsetWidth`, `offsetHeight`
`scrollTop`, `scrollLeft`, `scrollWidth`, `scrollHeight`
`clientTop`, `clientLeft`, `clientWidth`, `clientHeight`

获取以上属性时都会触发强制刷新



##### 优化

```js
// bad
div.style.left = div.offsetLeft + 10 + "px";
div.style.top = div.offsetTop + 10 + "px";

// good
var left = div.offsetLeft;
var top  = div.offsetTop;
div.style.left = left + 10 + "px";
div.style.top = top + 10 + "px";
/*
一般的规则是：
样式表越简单，重排和重绘就越快。
重排和重绘的DOM元素层级越高，成本就越高。
table元素的重排和重绘成本，要高于div元素。
*/
```





#### 并发限制

没有做并发限制，较大文件导致并发过多，tcp
链接被占光 ，需要做下并发控制，比如只有4个在请求在发送



#### 垃圾回收

回收原则：不可达的被回收

回收算法：标记清除算法

一般来说没有被引用的对象就是垃圾，就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除



### DevTool

#### 命令

`Ctrl + P` ：快速查找代码

`Ctrl + Shift + F`：全局查找

`ctrl+shif+o` ：文件中定位成员函数



#### 编辑器

拖动文件到chrome调试器，可以同步修改文件，内置编辑器



#### Console

##### Live Expression

根据监控的表达式，监控数据变化

执行频率：250毫秒



##### Store as global variable

将变量保存到全局，变量名为tempx



##### 常量

- $() : document.querySelector()的缩写，返回第一个与之匹配的CSS选择器的元素(例如：$('div') 它将返回本页的第一个div元素)。
- $$() : document.querySelectorAll()的缩写，返回一个数组，里面是与之匹配的CSS选择器的元素。
- $0?$4 : 依次返回五个最近你在元素面板选择过的DOM元素的历史记录，$0是最新的记录，以此类推。



##### 技巧

**保留每次的console**

勾选在Console标签下的保存日志选项，你可以使DevTools的console继续保存日志而不会在每个页面加载之后清除日志。



#### Element

##### 调色器
调色器可以进行rgba、16进制…..等颜色转换

在样式编辑器中选择一种颜色时，可以点击颜色预览，颜色选择器就会弹出。

##### 对元素右键
break on:可以在元素被删除或其他操作时自动断点



##### Eventlistener 

右键 show defined可以找到函数定义处



#### Source

##### 事件监听

`event listener breakpoint`勾选，当事件触发时自动断点



  ##### xhr/fetch breakpoints
    添加，可以捕获所有的url地址，也可以指定关键字捕获

  ##### 异常时自动暂停
    单步调试最右在异常时自动暂停，try catch中也能自动暂停

  ##### overrides
    在线调试：选择文件夹后，直接编辑网站的代码，刷新即可生效

##### Scope

利用好scope栏查看变量

##### snip

保存代码片段



#### Network

Network下右键copy as fetch

```js
// 可以复制整个请求并且手动发送 
var r = await fetch();console.log(await r.json())
```

### 性能优化

#### 响应内容大小

查看network看文件请求大小，若已启用，请求上可以看到压缩前后的大小分别是多少

对于大文件：看请求Header是否有content-encoding（一般是gzip, deflate, br）



##### 压缩

[Directives](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding#Directives)

- gzip 来自UNIX gzip程序的常见的压缩形式，其他命名x-gzip

- compress 来着UNIX压缩程序，由于专利问题，比较少用

- br Brotli algorithm

- identity

- deflate zlib structure的压缩



nodejs启用压缩

```js
const compression = require('compression');

app.use(compression());
```



#### 图片资源

- 换成小图片

- 设置多个大小的图片，浏览器会根据情况选中合适大小的图片[教程](https://developers.google.cn/web/fundamentals/design-and-ux/responsive/images#relative_sized_images)

- 使用CDN

- 图片压缩



#### 阻塞资源处理/Eliminate render-blocking resources

使用show Coverage查看代码利用率，减少不必要的文件加载

Show Request Blocking打开控制面板，可以block特定路径的文件请求



#### 优化加载内容

懒加载、异步加载、tree shaking



#### 减少主线程使用的时间

使用Performance，查看火焰图

根据Time块确定哪里占用大量时间，再看在这个时间内其他区块的哪部分是可以优化的，或者看出是由什么导致的



### 知识点

#### target="_blank"

当对a标签设置了target="_blank"时会产生的问题

```html
<a href="http://kaysonli.com/" target="_blank">1024译站</a>
```

**安全**

打开的新窗口可以通过window.opener读取并修改原窗口的信息，即使跨域被限制访问部分属性，仍会有一定的隐患



**性能**

通过target="_blank"打开的新窗口，会跟原来的页面窗口共用一个进程（看实际浏览器实现），阻塞会影响原页面





## 通用

### Cookies安全

浏览器安全设置，可能会导致cookies无法设置cookies(赋值后仍未空)

https://www.cnblogs.com/gxp69/p/12565927.html

https://blog.csdn.net/z69183787/article/details/39085259





### 跨域

#### 来源

同源策略

> 限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。通常不允许不同源间的读操作。



#### URI

```
[协议名]://[用户名]:[密码]@[主机名]:[端口]/[路径]?[查询参数]#[片段ID]
```

#### 同源

协议、主机名(host)以及端口三者均相同

> 主域和子域视为不同、域名与其对应的IP也视为不同
>
> 看着必须一样



#### 限制

Cookie、LocalStorage 和 IndexDB 无法读取。

DOM 无法获得。

AJAX 请求被拦截



#### CORS 跨域资源共享

Cross-origin resource sharing

##### 简单请求

**什么是简单请求**

普通 HTML Form 在不依赖脚本的情况下可以发出的请求



**特征**

三种请求方式之一：HEAD、GET、POST

 Header信息不超出以下几种字段

- Accept
- Accept-Language
- Content-Language
- Last-Event-ID
- Content-Type
  - application/x-www-form-urlencoded
  - multipart/form-data
  - text/plain
- DPR
- Downlink
- Save-Data
- Viewport-Width
- Width



**过程**

1、浏览器发送

浏览器会在Request Header中添加 Origin （协议 + 域名 + 端口）字段 ， 它表示我们的请求源，CORS服务端会将该字段作为跨源标志



2、服务器处理

接收到此次请求后 ， 首先会判断Origin是否在允许源（由服务端决定,Access-Control-Allow-Origin）范围之内，然后在Response Header 添加 Access-Control-Allow-Origin、Access-Control-Allow-Credentials等字段

必须字段

Access-Control-Allow-Origin

> 表示服务端允许的请求源，*标识任何外域，多个源 , 分隔,浏览器接收响应后会用来校验



可选字段

Access-Control-Allow-Credentials：false

> 表示是否允许发送Cookie，设置为true，同时，ajax请求设置withCredentials = true,浏览器的cookie就能发送到服务端，设置true时，Access-Control-Allow-Origin不能设置为*必须指定明确的，与请求网页一致的域名



Access-Control-Expose-Headers

> 调用getResponseHeader（）方法时候，能从header中获取的参数



3、浏览器接收

浏览器收到Respnose后会判断自己的源是否存在 Access-Control-Allow-Origin允许源中，如果不存在，会抛出“同源检测异常”



##### 预检请求

OPTIONS方法发起一个预检请求(preflight request)



**什么是预检请求**

**为什么有预检请求**

**预检请求作用**

询问服务器某个资源是否可以跨源，如果不允许的话就不发实际的请求,如果允许的话，浏览器会记住，然后发实际请求，且之后每次就都直接请求而不用再询问服务器否可以跨源了。



##### 复杂请求

普通 HTML Form 无法实现的请求

发起前会先发生预检请求，供服务器校验



##### 为什么要有简单请求、复杂请求

1、默认禁止跨源请求

许多服务器压根没打算给跨源用。当然你不给 CORS 响应头，浏览器也不会使用响应结果，但是请求本身可能已经造成了后果。所以最好是默认禁止跨源请求。

2、回答请求是否接受跨域总是要计算的，所以希望最好不用每次请求都让服务器劳神计算，从而有预检机制,节省服务器计算

3、简单请求是为了兼容普通表单发送请求而加入CORS机制？普通表单请求不经过CROS?

兼容的前提下发 preflight 对绝大多数服务器应用来说没有意义

没必要加，加了反而系统复杂化

4、为了安全考虑，由于服务器api并不会对调用拦截，只要api开放了，就可以被随意调用，所以浏览器通过CORS来block掉请求

如果浏览器没有CORS，则请求会直接发出去

是浏览器自身为了安全考虑增加的





### 问题

请求完成，但返回的缺少内容

> js缺少内容




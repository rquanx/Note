### .NET FrameWork

[源码](https://referencesource.microsoft.com/#mscorlib)



### Dictionary

典型的空间换时间，为了解决哈希冲突使用链接技术（chaining）

#### 实现

buckets数组和entries链表

- buckets：存储自己对应的entrie数组
- entries：以链表形式存储Key和Value

原理：根据Key计算出buckets数组的索引，然后从buckets[index]中获取到entries数组然后遍历查找结果

1、由于buckets和entries都是数组，开始时初始化需要设置容量
2、内部根据容量值计算“不小于该值的最小质数”作为实际容量

> 这么做的目的是减少碰撞几率，因为从哈希值定位buckets时会用到取模操作
> 设置合适的容量可以避免不必要的rehash
> 即使是空，也会被初始为容量是3

即便只创建了一个空字典，它至少也创建了两个长度为3的数组，再加上其他杂七杂八的字段，一个字典至少也占用了48个字节
当字典元素少得时候，用数组更好



### Array

如果 arrayType 为值类型，则将会有 allocationSize 个未封箱（unboxed）的 arrayType 值被创建。如果 arrayType 为引用类型，则将会有 allocationSize 个 arrayType 类型的引用被创建



### ArrayList

长度可变且可存储不同数据类型的数组

由于可存储不同类型的数据即object，在存储值类型数组存储值类型的时候是未封箱（unboxed）的会产生装箱，所以会产生额外开销



### List\<T\>

底层也是利用Array实现，复杂度基本一致

提供ArrayList一样的功能时，由于是泛型不存在装箱、拆箱

需要调整数组的容量，这就会发生新建数组、数据拷贝等一系列复杂且影响效率的操作



#### LinkedList\<T\>

链表

- 向链表中插入或删除节点无需调整结构的容量
- 特别适合以排序的顺序动态的添加新元素。如果要在数组的中间的某个位置添加新元素，不仅要移动所有其余的元素，甚至还有可能需要重新调整容量。

#### Queue\<T\>

初始化容量是 32
默认情况下，增长因子（growth factor）的值为 2.0，扩容时内部数组的长度会增加一倍

#### Stack\<T\>

初始化容量是 10

#### HashTable

利用哈希处理的数组

**普通数组存储**：
存储信息时，为了保证效率，一般是按顺序存储实现

> 按银行卡号唯一映射个人信息，由于卡号位数，虽然只有几张卡，但需要建立一个空间是银行卡号数字大小的数组，浪费99.999%的空间



**哈希存储**：
将索引进行哈希计算映射到小数组中
大数 --> 小数容易存在哈希冲突

哈希冲突解决
- 冲突避免机制（Collision Avoidance）：选择合适的哈希函数
    - 很多时候需要隐射的索引并不是完全随机，仍很容易存在冲突
- 冲突解决机制（Collision Resolution）
    - 开放寻址法：当位置被占用后，往后找位置存放（+1），容易出现同类哈希聚集问题（Secondary Clustering）
    - 二次探查：当位置占用后，同样找其他位置但不是线性，而是先检查 (s + 1)平方 处，然后检查(s - 1)平方，(s + 2)平方，(s - 2)平方，(s + 3)平方 依此类推
    - 二度哈希（rehashing）：.NET中实现使用的方法，也叫双重哈希（double hashing），准备n个哈希函数，当冲突时则使用下一个哈希函数，所有的哈希函数都类型，主要是乘法因子不同;哈希函数 Hk 的定义：`Hk(key) = [GetHash(key) + k * (1 + (((GetHash(key) >> 5) + 1) % (hashsize – 1)))] % hashsize`,在执行了 hashsize 次探查后，哈希表中的每一个位置都有且只有一次被访问到

